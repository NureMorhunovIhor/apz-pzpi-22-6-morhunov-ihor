Міністерство освіти і науки України
Харківський національний  університет радіоелектроніки

Кафедра програмної інженерії



ЗВІТ
з практичної роботи №1
з дисципліни «Архітектура програмного забезпечення»
на тему: «Патерни проєктування»


Виконав:	
ст. гр. ПЗПІ-22-6
Моргунов І.С.

Перевірив:
ст. викл. каф. ПІ
Сокорчук І.П.





Харків 2025
1 ІСТОРІЯ ЗМІН
Таблиця 1 – Історія змін 
№	Дата	Версія звіту	Опис змін та виправлень
1	27.04.2025	0.1	Створено розділ «Історія змін»
2	27.04.2025	0.1	Створено розділ «Завдання»
3	27.04.2025	0.1	Додано слайди презентації у додаток Б
4	27.04.2025	0.1	Додано програмний код, який розглядається у доповіді у додаток В
5	27.04.2025	0.1	Створено розділ «Опис виконаної роботи»
6	27.04.2025	0.1	Створено розділ «Висновки»
7	28.04.2025	0.1	Додано посилання на відеозапис та хронологічний опис доповіді у додаток А

 
2 ЗАВДАННЯ
1.	Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ»
2.	Створити та оформити слайди презентації доповіді
3.	Створити та опублікувати на YouTube відеозапис доповіді
4.	Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
5.	При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
6.	Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
7.	Створити у корені створеного репозиторію файл README.md з вказаним змістом та вказані директорії для окремих завдань
8.	Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
9.	Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1
 
3 ОПИС ВИКОНАНОЇ РОБОТИ
Патерн Iterator та яку проблему він вирішує
Interpreter — це поведінковий патерн проєктування, який визначає спосіб оцінки виразів мови (або граматики). Він дозволяє описати граматику для простої мови, а потім інтерпретувати речення цієї мови.
	Патерн Interpreter вирішує проблему аналізу і виконання виразів, побудованих за певною граматикою, наприклад:
-	математичних виразів
-	пошукових запитів
-	логічних виразів
-	умов у SQL-подібних мовах
Це зручно, коли:
-	граматика проста і нечасто змінюється
-	потрібно мати можливість будувати та обчислювати вирази під час виконання програми
Структура патернy
Патерн складається з наступних компонентів:
-	Абстрактний інтерпретатор (AbstractExpression) — оголошує метод interpret(Context context).
-	Термінальний вираз (TerminalExpression) — реалізує обчислення для термінальних (кінцевих) символів граматики.
-	Нетермінальний вираз (NonTerminalExpression) — реалізує правила для комбінації виразів (наприклад, додавання, множення тощо).
-	Контекст (Context) — містить інформацію, яка може знадобитися під час інтерпретації виразів (наприклад, значення змінних).

Використання патерну
У коді створюється набір класів, що реалізують інтерфейс Expression з методом interpret(). Вирази будуються у вигляді дерева об’єктів, яке можна обчислити, викликаючи interpret() для кореневого елементу.
	Переваги патерну
	Основні переваги патерну:
-	Можна легко додавати нові правила та вирази, створюючи нові класи.
-	Підходить для простих мов та граматик, які рідко змінюються.
-	Зрозуміла і наочна структура: кожне правило реалізовано у своєму класі.
-	Дає можливість описувати складні вирази як комбінацію об’єктів.
Недоліки патерну
Основні недоліки патерну:
-	Не підходить для складних або великих мов, оскільки кількість класів швидко зростає.
-	Може бути складно читати і підтримувати дерево виразів, якщо воно занадто велике.
-	Обчислення складних дерев виразів може бути повільним.
Приклад коду реалізації патерну
Приклад реалізації та використання патерну «Interpretator» на мові програмування Java наведений у Додатку В.
Рекомендації щодо використання патерну
-	Застосовуйте патерн Interpreter, коли потрібно обробляти просту граматику або мову.
-	Патерн підходить, якщо кількість правил обмежена і відома заздалегідь.
-	Використовуйте для побудови обчислювальних дерев виразів у логічних фільтрах, пошукових системах або генераторах SQL-подібних запитів.
-	Не варто використовувати для великих або змінних граматик — краще скористатися парсерами на основі BNF (наприклад, ANTLR).


4 ВИСНОВКИ
Патерн "Інтерпретатор" є ефективним інструментом об’єктно-орієнтованого проєктування, який дозволяє визначати граматику мови та будувати для неї інтерпретатор у вигляді об’єктної структури. Він особливо корисний у системах, де потрібно обробляти прості вирази або команди за заздалегідь визначеними правилами — наприклад, у логічних фільтрах, генераторах запитів чи пошукових системах.
Основною перевагою патерну є те, що він дозволяє інкапсулювати правила синтаксису у вигляді класів і спрощує додавання нових виразів без зміни існуючого коду, що відповідає принципам SOLID і покращує модульність системи.
Водночас слід пам’ятати, що при зростанні кількості правил граматики кількість класів також суттєво збільшується, що може ускладнити підтримку та розширення системи. Тому важливо зважено обирати цей патерн для тих випадків, де граматика є обмеженою та стабільною, щоб зберегти баланс між гнучкістю та складністю коду.
 
ДОДАТОК А
Відеозапис та хронологічний опис

Відеозапис доповіді на YouTube: https://www.youtube.com/watch?v=_NemYyPArs4
Хронологічний опис доповіді:
00:00 - Вступ
00:30 - Основна ідея патерну
00:55 - Структура патерну
02:28 - Переваги та недоліки патерну
04:10 - Застосування патерну
05:24 - Приклад коду(Арифметичний вираз)
06:13 - Приклад коду(Прости парсер команд)
06:52 - Рекомендації щодо використання патерну Interpreter
08:53 - Висновок
11:07 - Список використаних джерел
 
ДОДАТОК Б
Слайди презентації

 
Рисунок Б.1 – Титульний слайд

 
Рисунок Б.2 – Основна ідея патерну 

 
Рисунок Б.3 – Структура патерну

 
Рисунок Б.4 – Переваги і недоліки патерну

 
Рисунок Б.5 – Застосування патерну

 
Рисунок Б.6 – Приклад коду з використанням патерну у арифметичних виразах

 
Рисунок Б.7 – Приклад коду реалізації у простому парсері команд

 
Рисунок Б.8 – Рекомендації щодо використання патерну «Interpreter»

 
Рисунок Б.9 – Висновок

 
Рисунок Б.11 – Список використаних джерел
 
Рисунок Б.11 – Фінальний слайд “Дякую за увагу”

















ДОДАТОК В
Програмний код

GitHub репозиторій: https://github.com/NureMorhunovIhor/apz-pzpi-22-6-morhunov-ihor/blob/main/Pract1/pzpi-22-6-morhunov-ihor-design-pattern/interpretator-example.txt
1. class Expression:
2.     def interpret(self) -> int:
3.         pass
4. 
5. class Number(Expression):
6.     def __init__(self, value: int):
7.         self.value = value
8. 
9.     def interpret(self) -> int:
10.         return self.value
11. 
12. class Add(Expression):
13.     def __init__(self, left: Expression, right: Expression):
14.         self.left = left
15.         self.right = right
16. 
17.     def interpret(self) -> int:
18.         return self.left.interpret() + self.right.interpret()
19. 
20. # Використання 
21. expr = Add(Number(5), Number(3))  # 5 + 3
22. print(expr.interpret())  # Вивід: 8
23. 
24. class Context:
25.     def __init__(self, input_text: str):
26.         self.input_text = input_text
27. 
28. class Expression:
29.     def interpret(self, context: Context) -> bool:
30.         pass
31. 
32. class TerminalExpression(Expression):
33.     def __init__(self, data: str):
34.         self.data = data
35. 
36.     def interpret(self, context: Context) -> bool:
37.         return self.data in context.input_text
38. 
39. class OrExpression(Expression):
40.     def __init__(self, expr1: Expression, expr2: Expression):
41.         self.expr1 = expr1
42.         self.expr2 = expr2
43. 
44.     def interpret(self, context: Context) -> bool:
45.         return self.expr1.interpret(context) or self.expr2.interpret(context)
46. 
47. # Використання 
48. context = Context("Йди наліво або направо")
49. left = TerminalExpression("наліво")
50. right = TerminalExpression("направо")
51. direction = OrExpression(left, right)
52. 
53. print(direction.interpret(context))  # Вивід: True

